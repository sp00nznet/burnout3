"""
Output formatting and statistics for the recompiler.
"""

import json
import os


def write_summary(stats, output_dir):
    """Write a JSON summary of translation results."""
    summary_path = os.path.join(output_dir, "summary.json")
    with open(summary_path, "w", encoding="utf-8") as f:
        json.dump(stats, f, indent=2)
    return summary_path


def print_stats(stats):
    """Print translation statistics to stderr."""
    if isinstance(stats, dict) and "total" in stats:
        # Single batch stats
        _print_batch_stats(stats)
    else:
        # Per-category stats
        total_translated = 0
        total_failed = 0
        total_funcs = 0
        total_lines = 0

        for cat, cat_stats in sorted(stats.items()):
            _print_batch_stats(cat_stats, prefix=f"  {cat}: ")
            total_translated += cat_stats.get("translated", 0)
            total_failed += cat_stats.get("failed", 0)
            total_funcs += cat_stats.get("total", 0)
            total_lines += cat_stats.get("total_lines", 0)

        print(f"\n  Total: {total_translated}/{total_funcs} translated, "
              f"{total_failed} failed, {total_lines} lines of C")


def _print_batch_stats(stats, prefix=""):
    """Print stats for a single batch."""
    total = stats.get("total", 0)
    translated = stats.get("translated", 0)
    failed = stats.get("failed", 0)
    lines = stats.get("total_lines", 0)
    out_file = stats.get("output_file", "")
    out_size = stats.get("output_size", 0)

    pct = (translated / total * 100) if total > 0 else 0
    size_kb = out_size / 1024

    print(f"{prefix}{translated}/{total} functions ({pct:.1f}%), "
          f"{failed} failed, {lines} lines, {size_kb:.1f} KB -> {out_file}")


def generate_header(func_list, output_path):
    """
    Generate a C header with forward declarations for all translated functions.
    """
    lines = [
        "/**",
        " * Burnout 3: Takedown - Recompiled Function Declarations",
        " * Auto-generated by tools/recomp",
        " */",
        "",
        "#ifndef RECOMP_FUNCTIONS_H",
        "#define RECOMP_FUNCTIONS_H",
        "",
        '#include "recomp_types.h"',
        "",
    ]

    for addr, func_info in sorted(func_list):
        name = func_info.get("name", f"sub_{addr:08X}")
        lines.append(f"void {name}(void);")

    lines.extend(["", "#endif /* RECOMP_FUNCTIONS_H */", ""])

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    return output_path
