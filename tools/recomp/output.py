"""
Output formatting and statistics for the recompiler.
"""

import json
import os


def write_summary(stats, output_dir):
    """Write a JSON summary of translation results."""
    summary_path = os.path.join(output_dir, "summary.json")
    with open(summary_path, "w", encoding="utf-8") as f:
        json.dump(stats, f, indent=2)
    return summary_path


def print_stats(stats):
    """Print translation statistics to stderr."""
    if isinstance(stats, dict) and "total" in stats:
        # Single batch stats
        _print_batch_stats(stats)
    else:
        # Per-category stats
        total_translated = 0
        total_failed = 0
        total_funcs = 0
        total_lines = 0

        for cat, cat_stats in sorted(stats.items()):
            _print_batch_stats(cat_stats, prefix=f"  {cat}: ")
            total_translated += cat_stats.get("translated", 0)
            total_failed += cat_stats.get("failed", 0)
            total_funcs += cat_stats.get("total", 0)
            total_lines += cat_stats.get("total_lines", 0)

        print(f"\n  Total: {total_translated}/{total_funcs} translated, "
              f"{total_failed} failed, {total_lines} lines of C")


def _print_batch_stats(stats, prefix=""):
    """Print stats for a single batch."""
    total = stats.get("total", 0)
    translated = stats.get("translated", 0)
    failed = stats.get("failed", 0)
    lines = stats.get("total_lines", 0)
    out_file = stats.get("output_file", "")
    out_size = stats.get("output_size", 0)

    pct = (translated / total * 100) if total > 0 else 0
    size_kb = out_size / 1024

    print(f"{prefix}{translated}/{total} functions ({pct:.1f}%), "
          f"{failed} failed, {lines} lines, {size_kb:.1f} KB -> {out_file}")


def generate_header(func_list, output_path, abi_db=None):
    """
    Generate a C header with forward declarations for all translated functions.
    Uses ABI data for proper signatures when available.
    """
    abi_db = abi_db or {}

    lines = [
        "/**",
        " * Burnout 3: Takedown - Recompiled Function Declarations",
        " * Auto-generated by tools/recomp",
        " */",
        "",
        "#ifndef RECOMP_FUNCTIONS_H",
        "#define RECOMP_FUNCTIONS_H",
        "",
        '#include "recomp_types.h"',
        "",
    ]

    for addr, func_info in sorted(func_list):
        name = func_info.get("name", f"sub_{addr:08X}")
        abi_info = abi_db.get(addr, {})
        cc = abi_info.get("calling_convention", "cdecl")
        num_params = abi_info.get("estimated_params", 0)
        return_hint = abi_info.get("return_hint", "int_or_void")

        if return_hint in ("float_sse", "float"):
            ret_type = "float"
        elif return_hint == "int_zero":
            ret_type = "int"
        elif num_params == 0 and return_hint == "int_or_void":
            ret_type = "void"
        else:
            ret_type = "uint32_t"

        is_thiscall = cc in ("thiscall", "thiscall_cdecl")
        params = []
        if is_thiscall:
            params.append("void *this_ptr")
        for i in range(num_params):
            params.append(f"uint32_t a{i+1}")
        param_str = ", ".join(params) if params else "void"

        lines.append(f"{ret_type} {name}({param_str});")

    lines.extend(["", "#endif /* RECOMP_FUNCTIONS_H */", ""])

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    return output_path
